# PicoCTF - PIE TIME

## Challenge Overview
**Title:** PIE TIME 
**Category:** Binary Exploitation
**Difficulty:** Easy  
**Files Provided:** vuln.c, vuln

## Initial Analysis

From an initial look at the source code, we see that `main()` takes a value as an input, casts it to a function pointer and tries to execute it.

```c
unsigned long val;
printf("Enter the address to jump to, ex => 0x12345: ");
scanf("%lx", &val);
...
void (*foo)(void) = (void (*)())val;
foo();
```

We also see a `win()` function which prints the flag.

```c
int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  ...
```

This tells us that we have to somehow find the address of `win()` and enter it as our input.

## Detailed Analysis

A first idea is to disassemble the binary using `objdump` and find the address of `win()`.

### `objdump` Output
```
00000000000012a7 <win>:
    12a7:	f3 0f 1e fa          	endbr64 
    12ab:	55                   	push   rbp
    ...

000000000000133d <main>:
    133d:	f3 0f 1e fa          	endbr64 
    1341:	55                   	push   rbp
    ...
```

However as we can tell from the addresses we find and the title of the challenge (PIE TIME), the binary uses **Position Independent Executable** or **PIE** for short.  
We can also verify this using `readelf -h ./vuln` which prints the ELF header

### `readelf -h ./vuln` Output
```
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x11a0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          15280 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
```

`Type: DYN (Shared objecy file)` verifies that the binary uses **PIE** since otherwise it would say `Type: EXEC (Executable file)`

**PIE** means that every time the binary is run, its sections are mapped to a **different address** but they are never split (for example, splitting `win()` and `main()`).

What are the addresses we see from `objdump` then?

`objdump` shows **relative addresses** from the start of the section.

Since sections are not split, `main()` and `win()` will always have the **same distance** from each other which we can **calculate** by subtracting their relative addresses using a hex calculator.

**main() relative address:** 0x133d  
**win() relative address:** 0x12a7

**Difference:** 0x133d - 0x12a7 = 0x96

## Solution

When the binary is executed, it prints the actual address of `main()` for that instance.

```c
printf("Address of main: %p\n", &main);
```

By **subtracting** the given address of `main()` and the offset **0x96** we calculated, we can compute the address of `win()`

### Execution Example:
```
Address of main: 0x6092208d833d
Enter the address to jump to, ex => 0x12345: 
```

By subtracting 0x96 from the address of `main()` 0x6092208d833d we get **0x6092208d82a7**

So we enter **0x6092208d82a7**:
```
Your input: 6092208d82a7
You won!
picoCTF{FLAG}
```